{
    "docs": [
        {
            "location": "/", 
            "text": "ApplySyntax\n\n\nDetect and apply syntax in Sublime Text.\n\n\n\n\nOverview\n\n\nApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the \n.rb\n extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.\n\n\nCredits\n\n\nDetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:\n\n\n\n\nIt all started by forking the plugin created by JeanMertz \n(1)\n. I modified it quite extensively until I ended up with something entirely my own \n(2)\n. @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \nhard-coded\n to be valuable as a package, but then I took a look at SetSyntax \n(3)\n. and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.\n\n\n\n\n \nphillipkoebbe\n\n\nInstallation\n\n\nApplySyntax can be installed in a variety of ways:\n\n\n\n\n\n\nThrough Package Control \nPackage Control\n\n\n\n\nOpen Package Control\n\n\nSelect \nInstall Package\n\n\nFind and select \nApplySyntax\n\n\n\n\n\n\n\n\nBy cloning this repository in Packages\n\n\n\n\ncd into your Packages folder\n\n\ngit clone git://github.com/facelessuser/ApplySyntax.git\n\n\n\n\n\n\n\n\nBy downloading the files and placing them in a directory under \nPackages/ApplySyntax\n. If you download and extract a compressed archive from GitHub, the directory will be \nfacelessuser-ApplySyntax\n. Remove \nfacelessuser-\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#applysyntax", 
            "text": "Detect and apply syntax in Sublime Text.", 
            "title": "ApplySyntax"
        }, 
        {
            "location": "/#overview", 
            "text": "ApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the  .rb  extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.", 
            "title": "Overview"
        }, 
        {
            "location": "/#credits", 
            "text": "DetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:   It all started by forking the plugin created by JeanMertz  (1) . I modified it quite extensively until I ended up with something entirely my own  (2) . @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit  hard-coded  to be valuable as a package, but then I took a look at SetSyntax  (3) . and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.     phillipkoebbe", 
            "title": "Credits"
        }, 
        {
            "location": "/#installation", 
            "text": "ApplySyntax can be installed in a variety of ways:    Through Package Control  Package Control   Open Package Control  Select  Install Package  Find and select  ApplySyntax     By cloning this repository in Packages   cd into your Packages folder  git clone git://github.com/facelessuser/ApplySyntax.git     By downloading the files and placing them in a directory under  Packages/ApplySyntax . If you download and extract a compressed archive from GitHub, the directory will be  facelessuser-ApplySyntax . Remove  facelessuser- .", 
            "title": "Installation"
        }, 
        {
            "location": "/usage/", 
            "text": "User Guide\n\n\nConfiguring and using ApplySyntax.\n\n\n\n\nOverview\n\n\nApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins.\n\n\nApplySyntax allows you to create your own custom rules. The easiest way to get started is to create a settings file called \nApplySyntax.sublime-settings\n in your \nPackages/User\n folder.  You can override the default settings in \nPackages/ApplySyntax/ApplySyntax.sublime-settings\n by setting them in your \nPackages/User/ApplySyntax.sublime-settings\n file. You can override any setting to meet your needs.  To prepend rules to the default rule set, you can create a key called \nsyntaxes\n (modifying \ndefault_syntaxes\n will wipe out all the default rules and is not recommended as you won\nt get the latest updates).\n\n\nCreating Rules\n\n\nEach rule is a dictionary within the syntax array.  Let\ns take a look at the top level parameters.\n\n\nSyntax\n\n\nsyntax\n is the syntax file that will be applied to a view which meets the criteria defined in the rule.\n\n\nFor syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this: \nPackages/Rails/Language/*.tmLanguage\n, and you were looking to use the \nRuby Haml.tmLanguage\n file, the path to name translation would simply be: \nPackages/Rails/Language/Ruby Haml.tmLanguage\n -\n \nRails/Language/Ruby Haml\n.\n\n\nsyntax\n:\n \nRails/Language/Ruby Haml\n\n\n\n\n\n\nNotice that the paths are relative to the \nPackages\n folder.  Also, notice that we don\nt specify the extension.  Sublime Text in build 3084 added a new language syntax with the extension \nsublime-syntax\n.  In Sublime builds \n= 3084, ApplySyntax will first default to \nsublime-syntax\n and fall back to \ntmLanguage\n if it cannot find the the other format.  If you want to force the syntax, just specify the extension; the extension must be either \nsublime-syntax\n or \ntmLanguage\n.\n\n\nsyntax\n:\n \nRails/Language/Ruby Haml.tmLanguage\n\n\n\n\n\n\nIf it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example.  The first one found will be used.\n\n\nsyntax\n:\n \n[\nRSpec/RSpec\n,\n \nRSpec (snippets and syntax)/Syntaxes/RSpec\n]\n\n\n\n\n\n\nNotice that each syntax file has a different path since they come from completely different plugins.\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nname\n and has been deprecated and will be removed in the future.\n\n\n\n\nExtensions\n\n\nextensions\n is an easy way define extensions to apply a syntax to.  \nextensions\n is an array of strings where each string is an extension.  No \n.\n is needed when defining extensions, unless it is desired to target a dot file like \n.gitignore\n, then you would include the \n.\n.\n\n\nextensions\n is run before all other rules, and it never takes part in \nmatch all\n rule sets as it is run separate and before normal rule sets; if an extension is matched here, all other rules will be skipped.\n\n\nAn added benefit of \nextensions\n is if you are using ST3 and set \nadd_exts_to_lang_settings\n to \ntrue\n, ApplySyntax will add the extensions to the specified syntax language\ns settings file in your \nUser\n folder.  By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar.  Apply syntax will also create a file \nApplySyntax.ext-list\n in your \nUser\n folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable \nadd_exts_to_lang_settings\n by it to \nfalse\n.\n\n\n\n\nNote\n\n\nadd_exts_to_lang_settings\n will not be applied to \nextensions\n found in a \nproject specific rule\n, as project specific rules are not global, but the effects of \nadd_exts_to_lang_settings\n are global.\n\n\n\n\nMatch\n\n\nmatch\n is a setting that you either include or omit.  When included, you set it to \nall\n.  When set, all rules defined must be met for a match to be considered successful.  \nmatch\n ignores the \nextensions\n key as \nextensions\n never take part in \nmatch all\n rule sets.  If you want to include an extension rule in a \nmatch all\n rule set, then a \nfile_path\n rule should be used.\n\n\n    \nmatch\n:\n \nall\n\n\n\n\n\n\nSo in this case, all the rules must match for the syntax to be applied:\n\n\n     \nsyntax\n:\n \nHandlebars/Handlebars\n,\n\n     \nmatch\n:\n \nall\n,\n\n     \nrules\n:\n \n[\n\n         \n{\nfile_path\n:\n \n.*\\\\.html$\n},\n\n         \n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n     \n]\n\n\n\n\n\n\nIn this case, there is no \nmatch\n key, so only one rule needs to match:\n\n\n    \n{\n\n        \nsyntax\n:\n \nRuby/Ruby\n,\n\n        \nrules\n:\n \n[\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Gemfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Capfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Guardfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)[Rr]akefile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Berksfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)[Cc]heffile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Thorfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Podfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)config.ru$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$\n},\n\n            \n{\nfile_path\n:\n \n.*/Vagrantfile(/..*)?$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.thor$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rake$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.simplecov$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.jbuilder$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rb$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.podspec$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rabl$\n},\n\n            \n{\ninterpreter\n:\n \nruby\n}\n\n        \n]\n\n    \n},\n\n\n\n\n\n\nRules\n\n\nrules\n is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first rule matches, so order your rules in a way that makes sense to you.\n\n\nFile Path Rule\n\n\nA \nfile_path\n rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit \n^\n \u2014 so the pattern \n/a/b/c\n will match the file \n/a/b/c/foo.py\n, but not the file \n/x/y/z/a/b/c/foo.py\n. (You may include an explicit \n^\n at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.)\n\n\nFor backwards compatibility with older versions of ApplySyntax, the rule name \nfile_name\n is also accepted, and functions exactly like \nfile_path\n.\n\n\n{\nfile_path\n:\n \n.*\\\\.xml(\\\\.dist)?$\n},\n\n\n\n\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nfile_name\n and has been deprecated and will be removed in the future.\n\n\n\n\nFirst Line Rule\n\n\nA \nfirst_line\n rule allows you to check whether the first line of the file\ns content matches a given regex. As with \nfile_path\n \nrules\n, the pattern is always anchored to the beginning of the line.\n\n\n{\nfirst_line\n:\n \n^\n\\\\?xml\n},\n\n\n\n\n\n\nInterpreter (Shebang)\n\n\nAn \ninterpreter\n rule does the same thing as a \nfirst_line\n rule that uses a regex to match an interpreter directive (shebang).  The difference being that ApplySyntax will construct the regex for you.\n\n\nSo a \nfirst_line\n rule:\n\n\n{\nfirst_line\n:\n \n^#\\\\!(?:.+)ruby\n}\n\n\n\n\n\n\nCan be simplified as:\n\n\n{\ninterpreter\n:\n \nruby\n}\n\n\n\n\n\n\nFor backwards compatibility with older versions of ApplySyntax, the rule name \nbinary\n is also accepted, and functions exactly like \ninterpreter\n.\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nbinary\n and has been deprecated and will be removed in the future.\n\n\n\n\nFunction Rule\n\n\nThis is an example of using a custom function to decide whether or not to apply a syntax. The source file should be in a plugin folder. \nname\n is the function name and \nsource\n is the file in which the function is contained; you must include the package it resides in, all sub-folders leading to the file, and the actual file name (extension not needed as it is assumed to be a python file).\n\n\nWhen this function is called, the full file path of the given file will be passed to it as the only argument. You are free to do whatever you want in your function, just return \nTrue\n or \nFalse\n to indicate whether a match was made.  But please be conscious of keeping it quick and light if possible.\n\n\n{\nfunction\n:\n \n{\nname\n:\n \nis_rails_file\n,\n \nsource\n:\n \nApplySyntax/is_rails_file\n}}\n\n\n\n\n\n\n\n\nTip\n\n\nWhen placing a function rule module in a package, it is advised to put it in a sub-folder.  The sub-folder does not need an \n__init__.py\n, it just needs your module(s).\n\n\n\n\nContent Rule\n\n\nSometimes a filename or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching the content of a file can be enough.  You can search a file\ns content with regex for a specific token via the \ncontains\n rule.\n\n\n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n\n\n\n\n\n\n\nTip\n\n\nIt is recommended to pair \ncontains\n rules with other rules via the \nmatch\n:\n \nall\n option to ensure you don\nt search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the \ncontains\n rule after the other required rule(s) to ensure you search the content of as few files as possible.\n\n\nAlso, try to use very specific regex to ensure you don\nt get false positives.\n\n\n\n\nProject Specific Rules\n\n\nTo define project specific syntaxes, just add \nproject_syntaxes\n to your project file.  \nproject_syntaxes\n is an array; just add your syntax rules to \nproject_syntaxes\n just like you would add them to \nsyntaxes\n in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules.  The order of rules is as follows: project \n user \n default.\n\n\nThere is one difference between project specific rules and global rules.  In project rules, the \nextensions\n key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global.\n\n\n    \nproject_syntaxes\n:\n \n[\n\n        \n{\n\n            \nsyntax\n:\n \nXML/XML\n,\n\n            \nrules\n:\n \n[\n\n                \n{\nfile_path\n:\n \n.*\\\\.xml(\\\\.dist)?$\n},\n\n                \n{\nfirst_line\n:\n \n^\n\\\\?xml\n}\n\n            \n]\n\n        \n}\n\n    \n]\n\n\n\n\n\n\nSettings Options\n\n\nThere are a couple of general settings found in \nApplySyntax.sublime-settings\n.\n\n\nRe-Raise Exceptions\n\n\nIf an exception occurs when processing a function, this will re-raised the captured exception in Sublime\ns console so the user get feedback. This is really only useful to those writing functions. The average user shouldn\nt need this.  By default, the setting will be set to \nfalse\n.\n\n\n    \nreraise_exceptions\n:\n \nfalse\n,\n\n\n\n\n\n\nNew File Syntax\n\n\nIf you want to have a syntax applied when new files are created, set \nnew_file_syntax\n to the name of the syntax to use. The format is exactly the same as the \nsyntax\n parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set \nnew_file_syntax\n to \nJavaScript/JavaScript\n.  The default is \nfalse\n.\n\n\n    \nnew_file_syntax\n:\n \nJavaScript/JavaScript\n,\n\n\n\n\n\n\nAdd Extensions to Language Settings\n\n\nTo enable adding defined extensions to language settings, just set \nadd_exts_to_lang_settings\n to \ntrue\n.  See \nExtensions\n for more info.\n\n\n    \nadd_exts_to_lang_settings\n:\n \ntrue\n,\n\n\n\n\n\n\nTroubleshooting and Debugging\n\n\nBy default, the \ndebug\n setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working.  This can be turned off by setting \ndebug\n to \nfalse\n.  If developing, you can set \ndebug\n to \nverbose\n to get even more info in the console.\n\n\n    \n// Control level of logging in the console.\n\n    \n// (true|false|\nverbose\n)\n\n    \ndebug\n:\n \ntrue\n,", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#user-guide", 
            "text": "Configuring and using ApplySyntax.", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#overview", 
            "text": "ApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins.  ApplySyntax allows you to create your own custom rules. The easiest way to get started is to create a settings file called  ApplySyntax.sublime-settings  in your  Packages/User  folder.  You can override the default settings in  Packages/ApplySyntax/ApplySyntax.sublime-settings  by setting them in your  Packages/User/ApplySyntax.sublime-settings  file. You can override any setting to meet your needs.  To prepend rules to the default rule set, you can create a key called  syntaxes  (modifying  default_syntaxes  will wipe out all the default rules and is not recommended as you won t get the latest updates).", 
            "title": "Overview"
        }, 
        {
            "location": "/usage/#creating-rules", 
            "text": "Each rule is a dictionary within the syntax array.  Let s take a look at the top level parameters.", 
            "title": "Creating Rules"
        }, 
        {
            "location": "/usage/#syntax", 
            "text": "syntax  is the syntax file that will be applied to a view which meets the criteria defined in the rule.  For syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this:  Packages/Rails/Language/*.tmLanguage , and you were looking to use the  Ruby Haml.tmLanguage  file, the path to name translation would simply be:  Packages/Rails/Language/Ruby Haml.tmLanguage  -   Rails/Language/Ruby Haml .  syntax :   Rails/Language/Ruby Haml   Notice that the paths are relative to the  Packages  folder.  Also, notice that we don t specify the extension.  Sublime Text in build 3084 added a new language syntax with the extension  sublime-syntax .  In Sublime builds  = 3084, ApplySyntax will first default to  sublime-syntax  and fall back to  tmLanguage  if it cannot find the the other format.  If you want to force the syntax, just specify the extension; the extension must be either  sublime-syntax  or  tmLanguage .  syntax :   Rails/Language/Ruby Haml.tmLanguage   If it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example.  The first one found will be used.  syntax :   [ RSpec/RSpec ,   RSpec (snippets and syntax)/Syntaxes/RSpec ]   Notice that each syntax file has a different path since they come from completely different plugins.   Deprecation  The previous name for this key was  name  and has been deprecated and will be removed in the future.", 
            "title": "Syntax"
        }, 
        {
            "location": "/usage/#extensions", 
            "text": "extensions  is an easy way define extensions to apply a syntax to.   extensions  is an array of strings where each string is an extension.  No  .  is needed when defining extensions, unless it is desired to target a dot file like  .gitignore , then you would include the  . .  extensions  is run before all other rules, and it never takes part in  match all  rule sets as it is run separate and before normal rule sets; if an extension is matched here, all other rules will be skipped.  An added benefit of  extensions  is if you are using ST3 and set  add_exts_to_lang_settings  to  true , ApplySyntax will add the extensions to the specified syntax language s settings file in your  User  folder.  By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar.  Apply syntax will also create a file  ApplySyntax.ext-list  in your  User  folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable  add_exts_to_lang_settings  by it to  false .   Note  add_exts_to_lang_settings  will not be applied to  extensions  found in a  project specific rule , as project specific rules are not global, but the effects of  add_exts_to_lang_settings  are global.", 
            "title": "Extensions"
        }, 
        {
            "location": "/usage/#match", 
            "text": "match  is a setting that you either include or omit.  When included, you set it to  all .  When set, all rules defined must be met for a match to be considered successful.   match  ignores the  extensions  key as  extensions  never take part in  match all  rule sets.  If you want to include an extension rule in a  match all  rule set, then a  file_path  rule should be used.       match :   all   So in this case, all the rules must match for the syntax to be applied:        syntax :   Handlebars/Handlebars , \n      match :   all , \n      rules :   [ \n          { file_path :   .*\\\\.html$ }, \n          { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* } \n      ]   In this case, there is no  match  key, so only one rule needs to match:       { \n         syntax :   Ruby/Ruby , \n         rules :   [ \n             { file_path :   .*(\\\\\\\\|/)Gemfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Capfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Guardfile$ }, \n             { file_path :   .*(\\\\\\\\|/)[Rr]akefile$ }, \n             { file_path :   .*(\\\\\\\\|/)Berksfile$ }, \n             { file_path :   .*(\\\\\\\\|/)[Cc]heffile$ }, \n             { file_path :   .*(\\\\\\\\|/)Thorfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Podfile$ }, \n             { file_path :   .*(\\\\\\\\|/)config.ru$ }, \n             { file_path :   .*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$ }, \n             { file_path :   .*/Vagrantfile(/..*)?$ }, \n             { file_path :   .*\\\\.thor$ }, \n             { file_path :   .*\\\\.rake$ }, \n             { file_path :   .*\\\\.simplecov$ }, \n             { file_path :   .*\\\\.jbuilder$ }, \n             { file_path :   .*\\\\.rb$ }, \n             { file_path :   .*\\\\.podspec$ }, \n             { file_path :   .*\\\\.rabl$ }, \n             { interpreter :   ruby } \n         ] \n     },", 
            "title": "Match"
        }, 
        {
            "location": "/usage/#rules", 
            "text": "rules  is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first rule matches, so order your rules in a way that makes sense to you.  File Path Rule  A  file_path  rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit  ^  \u2014 so the pattern  /a/b/c  will match the file  /a/b/c/foo.py , but not the file  /x/y/z/a/b/c/foo.py . (You may include an explicit  ^  at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.)  For backwards compatibility with older versions of ApplySyntax, the rule name  file_name  is also accepted, and functions exactly like  file_path .  { file_path :   .*\\\\.xml(\\\\.dist)?$ },    Deprecation  The previous name for this key was  file_name  and has been deprecated and will be removed in the future.   First Line Rule  A  first_line  rule allows you to check whether the first line of the file s content matches a given regex. As with  file_path   rules , the pattern is always anchored to the beginning of the line.  { first_line :   ^ \\\\?xml },   Interpreter (Shebang)  An  interpreter  rule does the same thing as a  first_line  rule that uses a regex to match an interpreter directive (shebang).  The difference being that ApplySyntax will construct the regex for you.  So a  first_line  rule:  { first_line :   ^#\\\\!(?:.+)ruby }   Can be simplified as:  { interpreter :   ruby }   For backwards compatibility with older versions of ApplySyntax, the rule name  binary  is also accepted, and functions exactly like  interpreter .   Deprecation  The previous name for this key was  binary  and has been deprecated and will be removed in the future.   Function Rule  This is an example of using a custom function to decide whether or not to apply a syntax. The source file should be in a plugin folder.  name  is the function name and  source  is the file in which the function is contained; you must include the package it resides in, all sub-folders leading to the file, and the actual file name (extension not needed as it is assumed to be a python file).  When this function is called, the full file path of the given file will be passed to it as the only argument. You are free to do whatever you want in your function, just return  True  or  False  to indicate whether a match was made.  But please be conscious of keeping it quick and light if possible.  { function :   { name :   is_rails_file ,   source :   ApplySyntax/is_rails_file }}    Tip  When placing a function rule module in a package, it is advised to put it in a sub-folder.  The sub-folder does not need an  __init__.py , it just needs your module(s).   Content Rule  Sometimes a filename or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching the content of a file can be enough.  You can search a file s content with regex for a specific token via the  contains  rule.  { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* }    Tip  It is recommended to pair  contains  rules with other rules via the  match :   all  option to ensure you don t search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the  contains  rule after the other required rule(s) to ensure you search the content of as few files as possible.  Also, try to use very specific regex to ensure you don t get false positives.", 
            "title": "Rules"
        }, 
        {
            "location": "/usage/#project-specific-rules", 
            "text": "To define project specific syntaxes, just add  project_syntaxes  to your project file.   project_syntaxes  is an array; just add your syntax rules to  project_syntaxes  just like you would add them to  syntaxes  in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules.  The order of rules is as follows: project   user   default.  There is one difference between project specific rules and global rules.  In project rules, the  extensions  key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global.       project_syntaxes :   [ \n         { \n             syntax :   XML/XML , \n             rules :   [ \n                 { file_path :   .*\\\\.xml(\\\\.dist)?$ }, \n                 { first_line :   ^ \\\\?xml } \n             ] \n         } \n     ]", 
            "title": "Project Specific Rules"
        }, 
        {
            "location": "/usage/#settings-options", 
            "text": "There are a couple of general settings found in  ApplySyntax.sublime-settings .  Re-Raise Exceptions  If an exception occurs when processing a function, this will re-raised the captured exception in Sublime s console so the user get feedback. This is really only useful to those writing functions. The average user shouldn t need this.  By default, the setting will be set to  false .       reraise_exceptions :   false ,   New File Syntax  If you want to have a syntax applied when new files are created, set  new_file_syntax  to the name of the syntax to use. The format is exactly the same as the  syntax  parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set  new_file_syntax  to  JavaScript/JavaScript .  The default is  false .       new_file_syntax :   JavaScript/JavaScript ,   Add Extensions to Language Settings  To enable adding defined extensions to language settings, just set  add_exts_to_lang_settings  to  true .  See  Extensions  for more info.       add_exts_to_lang_settings :   true ,   Troubleshooting and Debugging  By default, the  debug  setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working.  This can be turned off by setting  debug  to  false .  If developing, you can set  debug  to  verbose  to get even more info in the console.       // Control level of logging in the console. \n     // (true|false| verbose ) \n     debug :   true ,", 
            "title": "Settings Options"
        }
    ]
}